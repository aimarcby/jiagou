异步通讯设计:
解决进程间的通信方式，分为同步调用和异步调用两种方式：
1、同步调用让系统间只耦合于接口，而且实时性也会比异步调用要高；
2、面对超高吐吞量的场景下，异步处理就比同步处理有比较大的优势了。

同步调用会带来如下几个问题：
1、同步调用需要被调用方的吞吐不低于调用方的吞吐。否则会导致被调用方因为性能不足而拖死调用方，整个同步调用链的性能会由最慢的那个服务所决定；
2、同步调用会导致调用方一直在等待被调用方完成，所有的参与方会有相同的等待时间，非常消耗调用方的资源；
3、同步调用只能是一对一的，很难做到一对多；
4、同步调用最大的缺点是，如果被调用方有问题，那么其调用方就会跟着出问题。

异步通讯通常来说有三种方式：
1、请求响应式：
运作方式：被请求方接收到请求后，直接返回——收到请求，正在处理；
对于返回结果，有两种方法，一种是发送方时不时地去轮询一下，问一下干没干完。
另一种方式是发送方注册一个回调方法，也就是接收方处理完后回调请求方。
不足：被调用方与发送方有一定的耦合。

2、通过订阅的方式：
运作方式：接收方会来订阅发送方的消息，发送方会把相关的消息或数据放到接收方所订阅的队列中，而接收方会从队列中获取数据。

3、通过Broker的方式：
在 Broker 这种模式下，发送方的服务和接收方的服务最大程度地解耦。
但是所有人都依赖于一个总线，所以这个总线就需要有如下的特性：
1）必须是高可用的，因为它成了整个系统的关键；
2）必须是高性能而且是可以水平扩展的；
3）必须是可以持久化不丢数据的。

4、事件驱动方式的好处至少有五个。
1）服务间的依赖没有了，服务间是平等的，每个服务都是高度可重用并可被替换的。
2）服务的开发、测试、运维，以及故障处理都是高度隔离的。
3）服务间通过事件关联，所以服务间是不会相互 block 的。
4）在服务间增加一些 Adapter（如日志、认证、版本、限流、降级、熔断等）相当容易。
5）服务间的吞吐也被解开了，各个服务可以按照自己的处理速度处理。

5、事件驱动的架构也会有一些不好的地方。
1）业务流程不再那么明显和好管理。整个架构变得比较复杂。解决这个问题需要有一些可视化的工具来呈现整体业务流程。
2）事件可能会乱序。这会带来非常 Bug 的事。解决这个问题需要很好地管理一个状态机的控制。
3）事务处理变得复杂。需要使用两阶段提交来做强一致性，或是退缩到最终一致性。

6、为什么要异步通讯。
1）异步通讯最重要的是解耦服务间的依赖。最佳解耦的方式是通过 Broker 的机制。
2）解耦的目的是让各个服务的隔离性更好，这样不会出现“一倒倒一片”的故障。
3）异步通讯的架构可以获得更大的吞吐量，而且各个服务间的性能不受干扰相对独立。
4）利用 Broker 或队列的方式还可以达到把抖动的吞吐量变成均匀的吞吐量，这就是所谓的“削峰”，这对后端系统是个不错的保护。
5）服务相对独立，在部署、扩容和运维上都可以做到独立不受其他服务的干扰。
